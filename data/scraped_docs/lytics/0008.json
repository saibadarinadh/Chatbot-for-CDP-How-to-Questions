{
  "title": "Client & Server Side Cookies",
  "content": "## What is a Cookie\nAn HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests. Typically, an HTTP cookie is used to tell if two requests come from the same browser\u2014keeping a user logged in, for example. It remembers stateful information for thestatelessHTTP protocol.\n\n## Cookie Flavors\n\n## First-party\nFirst-party cookies are created by the host domain \u2013 the domain the user is visiting. These cookies are generally considered good; they help provide a better user experience and keep the session open. This means the browser can remember key information, such as items you add to shopping carts, username, and language preferences.\n\n## Third-party\nThird-party cookies are those created by domains other than the one the user is visiting at the time and are mainly used for tracking and online-advertising purposes. They also allow website owners to provide certain services, such as live chats.\n\n## Common Cookie Use Cases\n\n## Session management\nLogins, shopping carts, game scores, or anything else the server should remember.\n\n## Personalization\nUser preferences, themes, and other settings.\n\n## Tracking\nRecording and analyzing user behavior.\n\n## How does Lytics use cookies?\nCookies are one of the preferred methods for maintaining a user identifier in the browser, both known and anonymous. This gets associated with all inbound events captured by our Javascript tag as they interact with customer websites. Specifically, our Javascript tag stores a string of digits and characters that are used as a unique ID commonly referred to as our_uidor, in some casesseeridas a first-party cookie.\n\n```\n_uid\n```\n\n```\nseerid\n```\n\n## Creating & Managing Cookies\n\n## Where do cookies come from?\n\n## Client-Side\nIn web development, the client-side refers to everything in a web application displayed on the client (end-user device). This includes what the user sees, such as text, images, and the rest of the UI, along with any actions an application performs within the user's browser.\nWhen someone refers to a \u201cclient-side cookie,\u201d they are generally referring to a cookie that is created and/or managed via a common client-side programming language such as Javascript.\n\n## Server Side\nLike with client-side, server-side means everything that happens on the server instead of on the client. In the past, nearly all business logic ran on the server-side, including rendering dynamic webpages, interacting with databases, identity authentication, and push notifications.\nWhen someone refers to a \u201cserver-side cookie,\u201d they are generally referring to a cookie that is created and managed using one of the many common server-side programming languages such as NodeJS, PHP, Python, etc.\n\n## Cookie Ingredients\n\n## Name\nDefines the cookie name. Generally, the cookie name is the primary way of retrieving a cookie and its associated value and attributes.\n\n## Value\nThe stored value for the cookie. This can include any US-ASCII character excluding a control character, whitespace, double quotes, comma, semicolon, and backslash.\n\n## Expires\nIndicates the maximum lifetime of the cookie as an HTTP-date timestamp. SeeDatefor the required formatting.\n\n```\nDate\n```\n\n## Max-Age\nIndicates the number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately.\n\n## Domain\nDefines the host to which the cookie will be sent.\n\n## Path\nIndicates the path that must exist in the requested URL for the browser to send theCookieheader.\n\n```\nCookie\n```\n\n## Secure\nThis indicates that the cookie is sent to the server only when a request is made with theHTTPS:scheme (except on localhost) and, therefore, is more resistant toman-in-the-middle attacks.\n\n```\nHTTPS:\n```\n\n## HttpOnly\nForbids JavaScript from accessing the cookie, for example, through theDocument.cookieproperty. Note that a cookie created withHttpOnlywill still be sent with JavaScript-initiated requests, for example, when callingXMLHttpRequest.send()orfetch(). This mitigates attacks against cross-site scripting (XSS).\n\n```\nDocument.cookie\n```\n\n```\nHttpOnly\n```\n\n```\nXMLHttpRequest.send()\n```\n\n```\nfetch()\n```\n\n## SameSite\nControls whether or not a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks (CSRF).\n\n## Who\u2019s taking away my cookies?!?\nIn June 2017, Apple introduced a new privacy feature calledIntelligent Tracking Prevention (ITP). This same feature was officially released in September 2017 with Safari 12 and iOS 11. Since then, the ITP has evolved and introduced several subsequent versions leading us to the current state (as of July 2022), which has many impacts on marketing but most notably:\n- ITP blocks all third-party cookies by default. (ITP 1.0/1.1)\n- ITP can grant exceptions to third-party cookies with Storage API. (ITP 2.0)\n- ITP caps all first-party cookies set with JavaScript to 7 days or 24 hours. (ITP 2.1/2.2)\n- ITP caps first-party cookies set by the server using CNAME cloaking to 7 days. (ITP 2.3)\nAs a result of the privacy and security efforts in general other browsers such as Mozilla\u2019s Firefox(ETP) and Google Chrome have followed suit in announcing and/or implementing their security and tracking protocols, which continue to impact tools such as third and first-party cookies that have long been a staple in providing the data necessary for marketers to personalize their communications effectively.\n\n## What can I do to replace my cookies?\nWith each iteration on more stringent privacy-related changes comes a wave of workarounds or alternate approaches to maintaining access to behavioral data essential to marketing:\n\n## 1. Deploy a strong first-party identification strategy.\nThere is no replacement then a strong identification strategy. Creating a relationship in which a user will openly share their identity through a login or some other authenticated means will always result in the highest level of certainty on identity, which leads to the best level of personalization. However, many use cases focus on anonymous users or users who have not built up the relationship necessary to unlock this level of authentication.\n\n## 2. First-party client-side cookies have changed but are still a viable solution.\nThough third-party cookies are effectively dead, first-party cookies are still viable for many use cases. Not only do they offer a very simple off-the-shelf type of implementation for leveraging, they also have a long shelf life, assuming that an anonymous user interacts frequently enough to overcome the 7-day expiration window.\n\n## 3. First-party server-side cookies offer an extended expiration window.\nOver the past 12 months, there has been a surge of interest in server-side cookies. This method for setting cookies currently is not affected by the ITP changes that impact client-side cookies, most notably the automatic expiration at seven days. Rather, server-side cookies can live for long periods, leading to a higher quality identification for anonymous users. The downside, however, is they are far more difficult to leverage than the client-side. They require a much more technical integration with whatever server-side technology is used to power the web asset and may not be accessible in the same manner as client-side cookies.\n\n## Getting Technical with Server Side Cookies\nIn general, regardless of the specific attribute settings used when leveraging server-side cookies, they currently are not impacted by the 7-day expiration window that client-side cookies fall victim to. However, Apple has made it clear that they have additional plans to extend some of the client-side cookie limitations to the server-side, and the most important attribute in that discussion is theHttpOnlyattribute.\n\n```\nHttpOnly\n```\nhttps://webkit.org/blog/9521/intelligent-tracking-prevention-2-3/\nAs a CDP and technology leader, we always aim to help our customers future-proof their implementations. As such, even though a non-HttpOnly server-side cookie offers an easier means to bypass current client-side restrictions, it is our recommendation to consider investing to leverageHttpOnlycookies set by the server-side to prevent any potential impacts of the next few iterations of ITP. Below we\u2019ll explore the two options and demonstrate the key differences.\n\n```\nHttpOnly\n```\n\n## Server Side Cookie without HttpOnly\nThe following example in Node.js demonstrates a sample snippet for setting the cookie server side. Most server-side languages have existing methods to make this very easy. In the case of creating a cookie for Lytics to leverage, you will also need to generate a unique ID which can be done in a variety of ways. In the case of Node, you may consider using therandomUUID() method of the Crypto interface. A simple Google search can lead you or your developer down the road of generating a unique ID that best fits your use case.\nOnce you have that unique ID, you simply set the cookie using the pre-defined Lytics name our Javascript tag is looking for. Alternatively, the tag can be configured to use any custom name.\n\n```\n// THE FOLLOWING REPRESENTS A UNTESTED AND NON-PRODUCTION LEVEL\n// EXAMPLE OF HOW TO SET A COOKIE SERVER SIDE WITH NODE.JS AND\n// ACCESS THE DOCUMENT.COOKIES FROM THE CLIENT SIDE\n\nvar express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\nvar crypto = require('crypto');\nvar dayjs = require('dayjs');\n\n// cookieParser middleware\napp.use(cookieParser());\n\n// route for setting the cookies\napp.get('/setcookie', function (req, res) {\n  // setting a server side cookie without httponly\n  res.cookie(\"seerid\", crypto.randomUUID(), {\n    httpOnly: false,\n    expires: dayjs().add(30, \"days\").toDate(),\n  });\n\n  res.send(`<html><body><p>A server side cookie has been set.</p></body></html>`);\n})\n\n// Route for getting all the cookies\napp.get('/getcookie', function (req, res) {\n    res.send(`\n        <html>\n            <head>\n                <script>\n                    alert(document.cookie);\n                </script>\n            </head>\n            <body>\n                <p>This is an example of how to get the cookies client side.</p>\n            </body>\n        </html>`\n    );\n})\n\napp.listen(3000, (err) => {\n    if (err) throw err;\n    console.log('server running on port 3000');\n});\n```\n\n```\n// THE FOLLOWING REPRESENTS A UNTESTED AND NON-PRODUCTION LEVEL\n// EXAMPLE OF HOW TO SET A COOKIE SERVER SIDE WITH NODE.JS AND\n// ACCESS THE DOCUMENT.COOKIES FROM THE CLIENT SIDE\n\nvar express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\nvar crypto = require('crypto');\nvar dayjs = require('dayjs');\n\n// cookieParser middleware\napp.use(cookieParser());\n\n// route for setting the cookies\napp.get('/setcookie', function (req, res) {\n  // setting a server side cookie without httponly\n  res.cookie(\"seerid\", crypto.randomUUID(), {\n    httpOnly: false,\n    expires: dayjs().add(30, \"days\").toDate(),\n  });\n\n  res.send(`<html><body><p>A server side cookie has been set.</p></body></html>`);\n})\n\n// Route for getting all the cookies\napp.get('/getcookie', function (req, res) {\n    res.send(`\n        <html>\n            <head>\n                <script>\n                    alert(document.cookie);\n                </script>\n            </head>\n            <body>\n                <p>This is an example of how to get the cookies client side.</p>\n            </body>\n        </html>`\n    );\n})\n\napp.listen(3000, (err) => {\n    if (err) throw err;\n    console.log('server running on port 3000');\n});\n```\nSince non-HttpOnly cookies are accessible out of the box client-side there is no additional lift necessary. Our tag will pick up the cookie and use that ID as the identifier. It is important to note that any UID changes must also be managed server-side as setting the cookie client-side will engage the 7-day expiration max. In this example, we simply raise an alert with the cookie string and do not show the actual implementation of the Lytics tag.\n\n## Server Side Cookie with HttpOnly\nSetting HttpOnly to true comes with an additional level of complexity but benefits from following the stringent and recommended guidelines of Apple ITP, which in theory will go farther in the way of future-proofing.\nMuch like the above example, we\u2019ll set a cookie, in this case using Node, in the same way. The only difference here is settinghttpOnlyto true. This means that the cookie is secure but will no longer be accessible out of the box by Javascript. Rather, you\u2019ll have to implement an alternative method for surfacing that ID to Javascript so that it can be passed to the Lytics Javascript tag and used during collection/resolution.\n\n```\nhttpOnly\n```\n\n```\n// THE FOLLOWING REPRESENTS A UNTESTED AND NON-PRODUCTION LEVEL\n// EXAMPLE OF HOW TO SET A COOKIE SERVER SIDE WITH NODE.JS AND\n// ACCESS THE DOCUMENT.COOKIES FROM THE CLIENT SIDE WHEN USING HTTPONLY\n\nvar express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\nvar crypto = require('crypto');\nvar dayjs = require('dayjs');\n\n// cookieParser middleware\napp.use(cookieParser());\n\n// route for setting the cookies\napp.get('/setcookie', function (req, res) {\n  // setting a server side cookie with httponly\n  res.cookie(\"uuid\", crypto.randomUUID(), {\n    httpOnly: true,\n    expires: dayjs().add(30, \"days\").toDate(),\n  });\n\n  res.send(`<html><body><p>A server side cookie has been set using httpOnly.</p></body></html>`);\n})\n\n// Route for getting all the cookies\napp.get('/getcookie', function (req, res) {\n    res.send(`\n        <html>\n            <head>\n                <script>\n                    var uuid = '${req.cookies.uuid}';\n                    alert(uuid);\n                </script>\n            </head>\n            <body>\n                <p>This is an example of how to get the cookies client side when cookie is httpOnly.</p>\n            </body>\n        </html>`\n    );\n})\n\napp.listen(3000, (err) => {\n    if (err) throw err;\n    console.log('server running on port 3000');\n});\n```\n\n```\n// THE FOLLOWING REPRESENTS A UNTESTED AND NON-PRODUCTION LEVEL\n// EXAMPLE OF HOW TO SET A COOKIE SERVER SIDE WITH NODE.JS AND\n// ACCESS THE DOCUMENT.COOKIES FROM THE CLIENT SIDE WHEN USING HTTPONLY\n\nvar express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\nvar crypto = require('crypto');\nvar dayjs = require('dayjs');\n\n// cookieParser middleware\napp.use(cookieParser());\n\n// route for setting the cookies\napp.get('/setcookie', function (req, res) {\n  // setting a server side cookie with httponly\n  res.cookie(\"uuid\", crypto.randomUUID(), {\n    httpOnly: true,\n    expires: dayjs().add(30, \"days\").toDate(),\n  });\n\n  res.send(`<html><body><p>A server side cookie has been set using httpOnly.</p></body></html>`);\n})\n\n// Route for getting all the cookies\napp.get('/getcookie', function (req, res) {\n    res.send(`\n        <html>\n            <head>\n                <script>\n                    var uuid = '${req.cookies.uuid}';\n                    alert(uuid);\n                </script>\n            </head>\n            <body>\n                <p>This is an example of how to get the cookies client side when cookie is httpOnly.</p>\n            </body>\n        </html>`\n    );\n})\n\napp.listen(3000, (err) => {\n    if (err) throw err;\n    console.log('server running on port 3000');\n});\n```\nAll code examples in this document are purely for demonstration. Any customer facing implementation should follow the guidance of our customer facing technical teams and the technical experts on our customer\u2019s end. These examples in production represent HIGH risk as documented.\nUpdatedabout 1 year ago",
  "url": "https://docs.lytics.com/docs/client-server-side-cookie-deep-dive"
}